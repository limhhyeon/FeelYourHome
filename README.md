# 🌡️IoT-TempLog💧
<img src="https://github.com/user-attachments/assets/f62e2632-126d-4395-b2c6-7d7818b8f9a2" width="700"/>


<br/><br/>

## 소개 및 개요
- 프로젝트 기간 : 2025.03.14 ~ 2025.03.21
- 인원 : 백엔드 1명


### [프로젝트 개요]:
이 프로젝트는 가스 벨브를 잠그지 않고 외출한 경험에서 아이디어를 얻어 시작되었습니다. 당시 불안한 마음에 집의 온도와 습도를 실시간으로 확인할 수 있는 시스템을 만들기로 결심하게 되었습니다. 이를 바탕으로 온도 및 습도 모니터링 시스템을 설계하여, 위험 상황을 미리 감지하고 알림을 받을 수 있는 기능을 제공하고자 했습니다.

### [프로젝트 설명]:
- 본 시스템은 ESP32 DHT22 센서를 사용하여 실시간 온도와 습도를 측정하고, 이를 MQTT Mosquitto 브로커를 통해 웹 서버로 전송합니다. 사용자는 설정된 온도 차이나 습도 기준을 초과할 경우, 실시간으로 이메일 알림을 받을 수 있으며, 이메일 알림 기능은 사용자가 선택적으로 활성화할 수 있어 불필요한 알림을 방지할 수 있습니다. 특히, 온도 차이가 일정 범위를 초과할 때 발생하는 알림은 위험 상황을 사전에 감지하여 사용자가 빠르게 대응할 수 있도록 돕습니다.

- 또한, 이 프로젝트는 카카오 소셜 로그인을 지원하여 사용자가 친구들과 쉽게 시스템을 공유하고 사용할 수 있도록 하였으며, 보안 측면에서는 JWT 인증과 HttpOnly 쿠키를 활용하여 웹 보안을 강화했습니다. 만약 기기가 연결 끊어짐 현상이 발생하면, Redis를 사용하여 구독 상태를 관리하고, 기기가 재연결될 경우 자동으로 구독을 복구할 수 있도록 설계되었습니다.

- 데이터 관리 측면에서 실시간 온도 및 습도 정보를 Redis에 캐시하여 빠르게 제공하고, 2시간마다 평균값을 DB에 저장하는 방식으로 효율적인 데이터 처리와 저장을 보장합니다. 이를 통해 사용자는 중요한 데이터가 빠르고 정확하게 제공되며, 시스템의 성능이 최적화됩니다.


## 1. 팀원 소개

| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;임홍현😺&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
| :---------------------: |
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[@limhhyeon](https://github.com/limhhyeon) |
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🖥️ Backend |


<br/>

## 2. 기술 스택
### [사용 기술]
#### **🛠️ Backend**  
![Java](https://img.shields.io/badge/java-%23ED8B00.svg?style=for-the-badge&logo=openjdk&logoColor=white) ![Spring](https://img.shields.io/badge/spring-%236DB33F.svg?style=for-the-badge&logo=spring&logoColor=white) ![Gradle](https://img.shields.io/badge/Gradle-02303A.svg?style=for-the-badge&logo=Gradle&logoColor=white) ![Hibernate](https://img.shields.io/badge/Hibernate-59666C?style=for-the-badge&logo=Hibernate&logoColor=white)  

#### **💻 Database & Cache**    
 ![MariaDB](https://img.shields.io/badge/MariaDB-003545?style=for-the-badge&logo=mariadb&logoColor=white)
![Redis](https://img.shields.io/badge/redis-%23DD0031.svg?style=for-the-badge&logo=redis&logoColor=white)  

#### **☁️ DevOps & Deployment**    
![AWS](https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&logo=amazon-aws&logoColor=white)
![Docker](https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)
![Nginx](https://img.shields.io/badge/nginx-%23009639.svg?style=for-the-badge&logo=nginx&logoColor=white)
![GitHub Actions](https://img.shields.io/badge/github%20actions-%232671E5.svg?style=for-the-badge&logo=githubactions&logoColor=white)  


### [커밋]
![GitHub](https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&logo=github&logoColor=white)

```java
feat: 새로운 기능을 추가했을 때
fix: 버그를 수정했을 때
docs: 문서 수정
refactor: 코드 개선했을 때
perf: 성능 최적화할 때
test: 테스트 코드 추가, 수정
build: 빌드 시스템이나 외부 의존성 변경할 때
ci: CI 설정 수정
```
<br/>

## 3. System Architecture & ERD
### [System Architecture]
 

####broker 처리


### [ERD]
![iotErd](https://github.com/user-attachments/assets/4074d0f0-5742-4cee-a1d0-c385c4ef00bb)


<br/>

## 4. 기능 전략

#### 1. **Auth (인증 관련 설계)**

- **이메일 중복 확인**: 사용자 등록 시 이메일 중복 체크 진행.
- **회원가입**: 이메일, 비밀번호 등 필수 정보를 입력하여 회원가입.
- **이메일 인증**: 인증번호를 이메일로 발송하여 사용자가 인증 후 이메일 사용 가능.
- **JWT 토큰 관리**: 로그인 시 JWT 토큰을 HttpOnly 및 secure 설정을 통해 쿠키에 저장, 보안 필터로 관리.
- **리프레시 토큰 관리**: 리프레시 토큰은 DB에서 관리하며, 만료된 액세스 토큰을 갱신할 때 사용.
- **소셜 로그인**: 카카오 소셜 로그인을 통해 간편하게 로그인.

---

#### 2. **제품 관리 (Product)**

##### *1) 클라이언트 사이드 (제품에 대한 설계)*

- **온도/습도 데이터 전송**:
    - 제품은 **클라이언트 ID와 비밀번호**를 내장하고 있어 Mosquitto 서버와의 연결 시 인증을 통해 안전하게 데이터 전송.
    - 온도 및 습도 정보는 1분마다 Mosquitto 서버로 전송되며, 해당 데이터는 서버에서 처리되고 저장된다.
- **Wi-Fi 연결**: IoT 제품은 Wi-Fi 기능을 갖추고 있어 **WiFiManager**를 사용하여 주변 Wi-Fi 네트워크를 등록할 수 있도록 설계.
- **구매된 상품 등록**: 구매된 제품에 대해서만 Mosquitto 서버에 퍼블리싱이 가능하도록 설정. 해당 제품의 **클라이언트 ID와 비밀번호**를 통해 인증된 사용자만 접근할 수 있도록 보안 강화.

##### *2) 서버 사이드 (서버에서 상품에 대한 설계)*

- **상품 등록 및 관리**:
    - IoT 제품은 **판매 전**에 DB에 등록되지 않으며, **판매된 상품만** 외부 API를 통해 구매된 후 DB에 등록되도록 설계.
    - **상품 번호 등록**: 구매한 상품은 웹사이트에서 **상품 번호**를 입력하여 등록.
- **알림 설정**:
    - 사용자가 설정한 기준에 따라 알림을 받을지 말지를 설정하는 기능.
    - **온도 차이 기준** 설정: 사용자는 **이전 온도와 현재 온도의 차이가 특정 기준을 초과할 때** 알림을 받을 수 있도록 설정하는 API 제공.
    - **알림 수신 여부 설정**: 사용자가 알림을 받을지 여부를 설정할 수 있는 API 제공.

---

#### 3. **센서 관리 (Sensor)**

- **사용자 피드백 반영**:
    - **온도/습도의 변화 확인**: 주변 사람들에게 온도와 습도를 어떻게 확인할 것인지 물어본 결과, **대부분의 사용자는 현재 온도와 습도만 확인하거나 오늘 하루 평균만 궁금해한다고 응답**했습니다. 이는 **실시간으로 변화하는 온도와 습도를 지속적으로 확인하는 것보다**, **현재 상태나 하루 평균 온도와 습도에 더 관심이 있다는 의견**이 많았다.
    - 이에 따라, **현재 시간의 온도와 습도만 확인할 수 있는 API**를 제공하기로 결정했다. 이를 통해 사용자가 더 간단하고 직관적으로 온도와 습도를 확인할 수 있도록 설계
- **온도/습도 데이터 저장**:
    - 실시간 온도와 습도 데이터는 **Redis에 저장**하여 DB의 과도한 부하를 줄이고, Redis에서 해당 데이터를 불러와 API를 통해 사용자에게 제공.
    - DB에는 2시간 간격으로 **평균 온도/습도** 데이터를 저장. 이때, 평균 습도가 경고 수준을 넘는 경우, **메일 알림**을 발송하도록 설계.
    - **이전 온도/습도 비교**: 실시간으로 수신된 온도/습도와 **Redis에서 이전 온도/습도를 가져와 비교**하고, 사용자가 설정한 **온도 차이** 기준을 초과하면 **실시간 메일 알림**을 전송하는 기능을 구현.

---

#### **4. 메일 전송 시스템**

- **알림 조건**: 실시간 온도 차이가 사용자 설정 기준을 초과하거나, 평균 습도가 경고 수준을 초과할 때 메일 전송.
- **메일 전송 로직**:
    - 사용자가 설정한 기준에 따라 메일을 전송하는 기능을 구현.
    - 메일 전송은 백그라운드 작업으로 처리되어, 실시간 알림을 유저에게 전달.

---

#### 5. **Mosquitto 서버**

- **보안 설정**: Mosquitto 서버에는 비밀번호를 설정하여 외부에서 무단으로 접근할 수 없도록 보안 강화.
- **클라이언트 인증**: DHT22 제품에는 고유의 클라이언트 ID와 비밀번호를 내장하여, Mosquitto 서버에서 인증된 클라이언트만 구독할 수 있도록 설계.
- **구독 관리**:
    - 제품이 꺼지면 해당 제품에 대한 구독을 취소.
    - 서버가 종료되었을 때, 활성화된 제품만 구독하여 리소스 낭비를 줄임.
    - 제품 상태 변경 시, 이를 Redis에 기록하고 주기적으로 DB에 상태 저장.

---

#### 6. **고려사항**

- **제품 상태 관리**:
    - 각 제품의 상태를 `UserProduct` 테이블에 저장하여 현재 제품의 활성화 상태를 추적.
    - 제품이 DB에 등록되지 않은 경우 구독 불가능하도록 설정.
- **서버 재시작 시 구독 관리**:
    - 서버가 꺼졌다 켜졌을 때, 현재 활성화된 제품만 구독하도록 설계.
    - 서버가 꺼지면 구독 취소 후, 서버가 재시작되면 해당 제품의 상태를 확인하여 구독 여부 결정.
- **Redis 활용 및 만료 설정**
    - **Redis**를 활용하여 **유저의 제품 정보**를 저장하고, Redis에서 데이터 만료 시 DB에서 데이터를 가져오는 방식으로 설계하여 성능 최적화.
    - 유저의 상품 정보 조회가 많을 것으로 예상되어, Redis를 **캐시**로 활용하고, **Redis 만료**가 발생하면 그때 DB에서 데이터를 조회하도록 구현.




<br/>


## 5. 트러블 슈팅


| 🔴 오류                           | 🔵 문제                                                                 | 🟢 해결 방법                                                               |
|---------------------------------|----------------------------------------------------------------------|--------------------------------------------------------------------------|
| `@PreDestroy에서 발생한 예외처리`  | `@PreDestroy`에서 Redis에서 값을 가져오기 전에 Redis 연결이 끊겨서 해당 값을 가져오지 못해 로그가 찍히지 않고 `@PreDestroy`가 실행되지 않음. | `@PreDestroy`가 실행되기 전에 Redis에서 먼저 값을 가져와 DB에 저장하는 로직을 `EventListener`로 처리하여, Redis와의 연결을 끊기 전에 값을 저장하도록 수정. |
| `DHT22 기기의 상태를 확인하는 방법` | 기기의 상태(켜짐/꺼짐)를 어떻게 알 수 있을지 고민하고 있었고, MQTT를 사용하여 기기의 상태를 관리하는 방법을 찾음. | MQTT Client를 사용하여 기기의 상태를 관리하고, `device/status/#` 토픽을 구독하여 기기의 상태 변경(켜짐/꺼짐)을 실시간으로 확인하고 처리하도록 함. |
| `서버 재시작 시 MQTT 구독 복원 문제` | 서버가 재시작된 후, MQTT에서 구독한 토픽들이 사라지고 다시 구독을 등록해야 하는 문제 발생. 특히, 상품 등록 시에만 구독을 하도록 설정했지만, 서버가 꺼졌다 켜지면 모든 구독 정보가 사라져 다시 등록해야 함. | 서버가 재시작될 때 활성화된 상품에 대해서만 구독을 다시 하도록 설정. 불필요한 구독을 피하기 위해 데이터베이스에서 활성화된 상품만 구독하도록 필터링하고, 페이지네이션을 통해 한 번에 너무 많은 데이터를 처리하지 않도록 수정. 1. **MQTT 연결 재시도 로직 추가**: MQTT 연결이 제대로 되지 않으면 최대 5번까지 재시도하며 연결을 시도. 연결이 실패하면 로그를 찍고 구독 초기화 실패 처리. 2. **활성화된 상품만 구독 복원**: 서버가 재시작될 때 데이터베이스에서 활성화된 상품들만 조회하여 구독을 다시 등록. 페이지네이션을 사용해 한 번에 너무 많은 데이터를 처리하지 않도록 함. `userProductRepository.findActiveMqttTopicsByActive(PageRequest.of(page, size))`를 사용해 활성화된 토픽들을 페이지 단위로 조회. |
| `Mosquitto 서버 접근 제어 문제`   | Mosquitto 서버에 누구나 접근할 수 있는 상태로 두면 보안상 문제가 발생할 수 있음. 이를 해결하기 위해 Mosquitto 서버에 접근 제어를 추가해야 한다. | Mosquitto 서버에 비밀번호를 설정하여 인증된 사용자만 접근할 수 있도록 구성. 각 클라이언트에 대한 고유한 `clientId`와 `password`를 관리하는 방식으로, 서버에 비밀번호를 몰라도 클라이언트는 파일에 저장된 정보를 통해 접근할 수 있도록 설정. |
| `IoT 온도/습도 데이터 Redis 저장 문제` | IoT 디바이스에서 온도와 습도 정보를 실시간으로 자주 받아오는 상황에서, 데이터를 매번 데이터베이스에 저장하면 DB 부하가 심할 수 있음. 이를 해결하기 위해 빠르게 데이터를 처리할 수 있는 방법이 필요함. | Redis를 활용하여 온도와 습도 데이터를 메모리에 저장한 후, 주기적인 스케줄러를 통해 데이터베이스에 한 번에 저장하는 방식으로 해결. 이를 통해 데이터베이스 부하를 줄이고, 빠른 데이터 처리를 가능하게 함. |



<br/>

## 6. 배운 기능

### * @PreDestroy *  

Spring 애플리케이션 종료 시점에 필요한 정리 작업을 수행할 수 있는 기능

#### 배운 점:  

##### 1. PreDestory의 역할  
- @PreDestroy는 빈이 소멸되기 직전에 호출되는 메서드를 정의할 때 사용  
- 주로 자원 정리, 세션 종료 처리, 캐시 저장, DB 저장 등 종료 직전 처리할 로직을 포함  

##### 2. 설정 방법  
- 메서드에 @PreDestroy를 선언하고, void 반환형으로 정의
- 파라미터를 받을 수 없으며 예외를 던지지 않는 구조로 작성해야 함 

##### 3. 적용 후 개선점  
- 불필요한 MQTT 구독 제거로 서버 재시작 시 깔끔한 상태 유지
- 자원 해제 안정성 확보 → MQTT 연결 등 외부 리소스를 명확하게 종료 가능
- 예측 가능한 종료 처리로 유지보수 용이


### * MQTT와 Mosquitto *  

**MQTT(Message Queuing Telemetry Transport)**는 경량의 메시지 큐 프로토콜로, IoT(Internet of Things) 환경에서 주로 사용되고. 저전력, 저대역폭 네트워크에서 효율적으로 데이터를 전송할 수 있어 IoT 장치 간의 실시간 메시지 통신에 적합하다. Mosquitto는 MQTT 프로토콜을 구현한 오픈소스 브로커로, MQTT 기반의 메시징 시스템을 관리하는 역할을 합니다.

#### 배운 점:  

##### 1. MQTT의 역할  
- 경량 메시징 프로토콜: IoT 환경에서 적합한 경량의 메시징 시스템으로, 낮은 대역폭과 전력 소비로 데이터를 효율적으로 전송. 
- 퍼블리시-서브스크라이브 모델: 클라이언트는 데이터를 퍼블리시(발행)하고, 다른 클라이언트는 이를 서브스크라이브(구독)하여 실시간으로 데이터를 수신.
- 주제 기반 메시지 전송: 주제(topic)를 기반으로 메시지를 전달하여, 관심 있는 주제만 구독하여 필요한 데이터만 받을 수 있음.

##### 1-2. Mosquitto의 역할
- MQTT 브로커: Mosquitto는 MQTT 프로토콜을 사용하는 브로커로, 클라이언트 간의 메시지를 중계하고, 연결, 구독 및 퍼블리시된 메시지를 관리.
- 클라이언트 관리: 클라이언트들이 연결을 설정하고, 메시지를 주고받을 수 있도록 중계하는 역할을 함
- 보안 기능: Mosquitto는 인증, 암호화, 클라이언트 ID 관리 등의 보안 기능을 제공하여 안전한 메시지 통신을 보장.

##### 2. 설정 방법  
- MQTT 연결 설정: Mosquitto 브로커와 클라이언트 간의 연결을 설정하고, 주제를 기반으로 메시지를 주고받도록 설정.
- 클라이언트 인증: Mosquitto는 사용자 인증을 위한 기능을 제공하여, MQTT 브로커에 접근하는 클라이언트를 관리.

##### 3. 적용 후 개선점  
- 실시간 데이터 전송: IoT 장치 간의 실시간 데이터 전송을 지원하여, 온도, 습도 등의 센서 데이터를 실시간으로 처리.
- 확장성: MQTT와 Mosquitto를 활용하여 수많은 IoT 장치를 효율적으로 관리하고 통신할 수 있게 됨.
- 보안 강화: Mosquitto에서 제공하는 인증 및 암호화 기능을 통해, IoT 장치 간의 안전한 데이터 통신을 보장.
- 효율적인 메시징: 퍼블리시-서브스크라이브 모델을 통해 효율적으로 데이터 전송을 관리하고, 불필요한 데이터 전송을 최소화.

### * @EventListener *  

Spring 애플리케이션에서 특정 이벤트가 발생했을 때, 이를 처리하기 위한 리스너 기능.

#### 배운 점:  

##### 1. @EventListener의 역할
- @EventListener는 애플리케이션 이벤트가 발생했을 때 이를 수신하고 처리하는 메서드를 정의하는 어노테이션입니다.
- 주로 애플리케이션의 상태 변화, 종료 등과 같은 이벤트에 반응하여 특정 작업을 실행할 때 사용됩니다. 

##### 2. 설정 방법  
- @EventListener는 메서드에 선언하여 이벤트 리스닝을 설정합니다.
- 특정 이벤트에 반응하도록 메서드를 정의하고, 해당 이벤트가 발생했을 때 실행할 로직을 작성합니다.

##### 3. 적용 후 개선점  
- 서버 종료 시점에 @PreDestroy를 사용하는 대신, @EventListener를 사용하여 애플리케이션 종료 이벤트를 수신하고, Redis 데이터를 안전하게 DB에 저장하도록 했습니다.
- Redis 연결이 종료되기 전에 이벤트 리스너가 실행되어 필요한 데이터를 처리할 수 있어, 데이터 손실을 방지하고 안정적인 종료 처리가 가능했습니다.
- 애플리케이션 종료 전에 처리해야 할 중요한 로직을 실행하는 유연한 방법을 제공하여 서버 종료 전 상태 관리에 대한 신뢰성을 높였습니다.

### * OAuth2 *  

OAuth2(Open Authorization 2.0)은 외부 애플리케이션이 사용자의 데이터를 안전하게 접근할 수 있도록 권한을 부여하는 인증 프로토콜입니다. 주로 소셜 로그인 기능에서 사용되며, 사용자가 자신의 계정 정보를 공유하지 않고도 제3자 애플리케이션이 서비스에 접근할 수 있게 도와줍니다.

#### 배운 점:  

##### 1. OAuth2의 역할
- 권한 부여: 사용자가 자신의 인증 정보를 직접 제공하지 않고, 외부 애플리케이션이 안전하게 사용자 데이터를 접근할 수 있도록 권한을 부여.
- 액세스 토큰 발급: 사용자가 로그인하면, 인증 서버는 클라이언트 애플리케이션에 액세스 토큰을 발급. 이를 통해 외부 애플리케이션은 사용자의 데이터를 안전하게 조회할 수 있음.

##### 2. 설정 방법  
- OAuth2 설정: 인증 서버(예: Google, Facebook, Kakao)와의 연결을 설정하고, 액세스 토큰을 요청할 수 있도록 클라이언트 애플리케이션을 구성.
- 소셜 로그인 구현: OAuth2 프로토콜을 사용하여 소셜 로그인 시스템을 구현하고, 다양한 소셜 플랫폼에서 제공하는 인증 API를 통해 사용자의 로그인 정보를 처리.
- 토큰 저장: 발급된 액세스 토큰과 리프레시 토큰을 클라이언트 애플리케이션에 안전하게 저장하여 사용.

##### 3. 적용 후 개선점  
- 간편한 소셜 로그인: 기존의 복잡한 소셜 로그인 로직을 간소화하여 보안적이고 효율적인 로그인 프로세스 구현과 정보에 민감한 code 등 url등을 서비스에서 이용 안할 수 있어 보안적으로 개선.
- 보안성 강화: 사용자 인증 정보를 클라이언트 애플리케이션에 저장하지 않고, 안전하게 인증 서버를 통해 처리. 액세스 토큰을 사용하여 외부 애플리케이션에서만 사용자의 데이터를 접근 가능.
- 유연한 권한 관리: OAuth2 프로토콜을 통해 특정 범위(scope)만 요청하여, 사용자의 개인정보를 최소화하고 보호할 수 있음.






<br/>


## 7. 느낀점


