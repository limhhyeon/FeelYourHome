# 🌡️IoT-TempLog💧
<img src="https://github.com/user-attachments/assets/f62e2632-126d-4395-b2c6-7d7818b8f9a2" width="700"/>


<br/><br/>

## 소개 및 개요
- 프로젝트 기간 : 2025.03.14 ~ 2025.03.21
- 인원 : 백엔드 1명


### [프로젝트 개요]:
이 프로젝트는 가스 벨브를 잠그지 않고 외출한 경험에서 아이디어를 얻어 시작되었습니다. 당시 불안한 마음에 집의 온도와 습도를 실시간으로 확인할 수 있는 시스템을 만들기로 결심하게 되었습니다. 이를 바탕으로 온도 및 습도 모니터링 시스템을 설계하여, 위험 상황을 미리 감지하고 알림을 받을 수 있는 기능을 제공하고자 했습니다.

### [프로젝트 설명]:
- 본 시스템은 ESP32 DHT22 센서를 사용하여 실시간 온도와 습도를 측정하고, 이를 MQTT Mosquitto 브로커를 통해 웹 서버로 전송합니다. 사용자는 설정된 온도 차이나 습도 기준을 초과할 경우, 실시간으로 이메일 알림을 받을 수 있으며, 이메일 알림 기능은 사용자가 선택적으로 활성화할 수 있어 불필요한 알림을 방지할 수 있습니다. 특히, 온도 차이가 일정 범위를 초과할 때 발생하는 알림은 위험 상황을 사전에 감지하여 사용자가 빠르게 대응할 수 있도록 돕습니다.

- 또한, 이 프로젝트는 카카오 소셜 로그인을 지원하여 사용자가 친구들과 쉽게 시스템을 공유하고 사용할 수 있도록 하였으며, 보안 측면에서는 JWT 인증과 HttpOnly 쿠키를 활용하여 웹 보안을 강화했습니다. 만약 기기가 연결 끊어짐 현상이 발생하면, Redis를 사용하여 구독 상태를 관리하고, 기기가 재연결될 경우 자동으로 구독을 복구할 수 있도록 설계되었습니다.

- 데이터 관리 측면에서 실시간 온도 및 습도 정보를 Redis에 캐시하여 빠르게 제공하고, 2시간마다 평균값을 DB에 저장하는 방식으로 효율적인 데이터 처리와 저장을 보장합니다. 이를 통해 사용자는 중요한 데이터가 빠르고 정확하게 제공되며, 시스템의 성능이 최적화됩니다.


## 1. 팀원 소개

| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;임홍현😺&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
| :---------------------: |
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[@limhhyeon](https://github.com/limhhyeon) |
| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🖥️ Backend |


<br/>

## 2. 기술 스택
### [사용 기술]
#### **🛠️ Backend**  
![Java](https://img.shields.io/badge/java-%23ED8B00.svg?style=for-the-badge&logo=openjdk&logoColor=white) ![Spring](https://img.shields.io/badge/spring-%236DB33F.svg?style=for-the-badge&logo=spring&logoColor=white) ![Gradle](https://img.shields.io/badge/Gradle-02303A.svg?style=for-the-badge&logo=Gradle&logoColor=white) ![Hibernate](https://img.shields.io/badge/Hibernate-59666C?style=for-the-badge&logo=Hibernate&logoColor=white)  

#### **💻 Database & Cache**    
 ![MariaDB](https://img.shields.io/badge/MariaDB-003545?style=for-the-badge&logo=mariadb&logoColor=white)
![Redis](https://img.shields.io/badge/redis-%23DD0031.svg?style=for-the-badge&logo=redis&logoColor=white)  

#### **☁️ DevOps & Deployment**    
![AWS](https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&logo=amazon-aws&logoColor=white)
![Docker](https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)
![Nginx](https://img.shields.io/badge/nginx-%23009639.svg?style=for-the-badge&logo=nginx&logoColor=white)
![GitHub Actions](https://img.shields.io/badge/github%20actions-%232671E5.svg?style=for-the-badge&logo=githubactions&logoColor=white)  


### [커밋]
![GitHub](https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&logo=github&logoColor=white)

```java
feat: 새로운 기능을 추가했을 때
fix: 버그를 수정했을 때
docs: 문서 수정
refactor: 코드 개선했을 때
perf: 성능 최적화할 때
test: 테스트 코드 추가, 수정
build: 빌드 시스템이나 외부 의존성 변경할 때
ci: CI 설정 수정
```
<br/>

## 3. System Architecture & ERD
### [System Architecture]
 

####broker 처리


### [ERD]
![iotErd](https://github.com/user-attachments/assets/4074d0f0-5742-4cee-a1d0-c385c4ef00bb)


<br/>

## 4. 기능 전략

#### 1. Auth (인증 관련 설계)
- ` JWT 기반 인증 `: 로그인 시 **Access Token**과 **Refresh Token** 발급, Access Token은 **HttpOnly**, **Secure** 쿠키에 저장해 **XSS 공격** 방지. Refresh Token은 DB에서 관리, 만료 시 자동 재발급으로 세션 유지.
- ` 이메일 인증 `: 회원가입 시 이메일로 인증번호 발송, 인증 완료 후 계정 활성화. 이메일 중복 체크로 고유성 보장.
- ` 소셜 로그인 `: **카카오** OAuth2 기반 소셜 로그인 지원, 간편 인증 제공.
- ` 캐싱 전략 `: 사용자 프로필 정보 조회 빈도 높아 **Redis** 캐싱 적용, DB 접근 최소화.
- ` 보안 고려사항 `:
  - **CSRF 방지**: 쿠키에 **SameSite** 속성 설정, **Origin/Referer** 검증.
  - **로그아웃 처리**: 쿠키와 서버 토큰 삭제로 세션 완전 종료.

####  2. Product (제품 관리)

##### 서버 사이드 (서버에서 상품에 대한 설계)
- ` 상품 등록 `: 구매된 제품만 외부 API로 검증 후 DB 등록, 웹사이트에서 **상품 번호** 입력으로 사용자 소유권 확인.
- ` 알림 설정 `: 온도 차이 기준 초과 시 알림, 사용자별 알림 수신 여부 설정 API 제공.
- ` 캐싱 최적화 `: 빈번한 제품 정보 조회를 **Redis** 캐싱으로 처리, 캐시 만료 시 DB 조회로 성능 향상.
- ` 상태 관리 `: **UserProduct** 테이블로 제품 활성화 상태 추적, 미등록 제품은 접근 차단.

##### 클라이언트 사이드 (제품에 대한 설계)
- ` 데이터 전송 `: IoT 제품이 **Mosquitto 서버**로 1분 주기 온도/습도 데이터 전송, **클라이언트 ID**와 **비밀번호** 인증으로 보안 유지.
- ` Wi-Fi 연결 `: **WiFiManager**로 제품의 Wi-Fi 네트워크 연결 지원, 사용자 친화적 설정 제공.
- ` 보안 인증 `: 구매된 제품만 Mosquitto 서버 퍼블리싱 가능, 인증된 사용자만 데이터 접근.

- ` 고려사항 `:
  - **보안**: 미등록 제품은 Mosquitto 서버 접근 불가, 인증된 사용자만 데이터 조회.
  - **효율성**: Redis 캐싱으로 빈번한 조회 성능 최적화, 서버와 클라이언트 간 데이터 전송 안정화.

####  3. Sensor (센서 관리) 
- ` 데이터 처리 `: 실시간 온도/습도 데이터를 **Redis**에 저장, DB 부하 감소. 2시간 주기 **평균 온도/습도**를 DB에 저장.
- ` 사용자 피드백 반영 `: 조사 결과, 사용자는 **현재 온도/습도** 또는 **하루 평균값** 선호. 이에 **실시간 조회 API** 제공.
- ` 알림 로직 `: Redis로 이전 데이터와 비교, 사용자 설정 온도 차이 초과 시 **실시간 메일 알림**. 평균 습도 경고 수준 초과 시 추가 알림.
- ` 고려사항 `:
  - **성능**: Redis 캐싱으로 실시간 데이터 조회 속도 향상, DB 접근 최소화.
  - **사용자 경험**: 복잡한 변화 추적 대신 간단한 현재 상태 조회 중심 설계.

#### 4. Mail System (메일 전송 시스템)
- ` 알림 트리거 `: 온도 차이 또는 평균 습도 경고 수준 초과 시 메일 발송.
- ` 비동기 처리 `: 메일 전송을 **백그라운드 작업**으로 처리, 시스템 지연 방지.
- ` 고려사항 `:
  - **안정성**: 메일 전송 실패 시 재시도 로직 적용, 사용자 알림 신뢰도 유지.
  - **확장성**: 대량 메일 전송 대비 큐 기반 처리 구조 도입 가능성 검토.

#### 5. Mosquitto Server (MQTT 서버 관리)
- ` 보안 인증 `: **비밀번호** 설정 및 **클라이언트 ID/비밀번호**로 제품 인증, 외부 접근 차단.
- ` 구독 관리 `: 제품 종료 시 구독 취소, 서버 재시작 시 **Redis**에서 활성화 상태 확인 후 재구독.
- ` 상태 저장 `: 제품 상태(켜짐/꺼짐)를 Redis에 기록, 주기적으로 DB 동기화.
- ` 고려사항 `:
  - **리소스 효율**: 비활성 제품 구독 방지로 서버 부하 감소.
  - **복구**: 서버 재시작 시 상태 복원 로직으로 데이터 유실 방지.

#### 6. Considerations (종합 고려사항)
- ` 제품 상태 관리 `: **UserProduct** 테이블로 제품 활성화 여부 추적, 미등록 제품은 구독 불가로 보안 강화.
- ` 캐싱 최적화 `: 사용자 정보, 제품 데이터, 센서 데이터 등 빈번한 조회 항목을 **Redis**에 저장, 캐시 만료 시 DB 조회로 성능 유지.
- ` 서버 재시작 대응 `: 서버 종료/재시작 시 Redis와 DB 간 상태 동기화, 활성화 제품만 구독으로 리소스 낭비 최소화.
- ` 사용자 경험 `: 복잡한 데이터 대신 현재 상태 중심 API 제공, 알림 설정으로 사용자 맞춤형 정보 전달.


<br/>


## 5. 트러블 슈팅


| 🔴 오류                           | 🔵 문제                                                                 | 🟢 해결 방법                                                               |
|---------------------------------|----------------------------------------------------------------------|--------------------------------------------------------------------------|
| `@PreDestroy에서 발생한 예외처리`  | `@PreDestroy`에서 Redis에서 값을 가져오기 전에 Redis 연결이 끊겨서 해당 값을 가져오지 못해 로그가 찍히지 않고 `@PreDestroy`가 실행되지 않음. | `@PreDestroy`가 실행되기 전에 Redis에서 먼저 값을 가져와 DB에 저장하는 로직을 `EventListener`로 처리하여, Redis와의 연결을 끊기 전에 값을 저장하도록 수정. |
| `DHT22 기기의 상태를 확인하는 방법` | 기기의 상태(켜짐/꺼짐)를 어떻게 알 수 있을지 고민하고 있었고, MQTT를 사용하여 기기의 상태를 관리하는 방법을 찾음. | MQTT Client를 사용하여 기기의 상태를 관리하고, `device/status/#` 토픽을 구독하여 기기의 상태 변경(켜짐/꺼짐)을 실시간으로 확인하고 처리하도록 함. |
| `서버 재시작 시 MQTT 구독 복원 문제` | 서버가 재시작된 후, MQTT에서 구독한 토픽들이 사라지고 다시 구독을 등록해야 하는 문제 발생. 특히, 상품 등록 시에만 구독을 하도록 설정했지만, 서버가 꺼졌다 켜지면 모든 구독 정보가 사라져 다시 등록해야 함. | 서버가 재시작될 때 활성화된 상품에 대해서만 구독을 다시 하도록 설정. 불필요한 구독을 피하기 위해 데이터베이스에서 활성화된 상품만 구독하도록 필터링하고, 페이지네이션을 통해 한 번에 너무 많은 데이터를 처리하지 않도록 수정. 1. **MQTT 연결 재시도 로직 추가**: MQTT 연결이 제대로 되지 않으면 최대 5번까지 재시도하며 연결을 시도. 연결이 실패하면 로그를 찍고 구독 초기화 실패 처리. 2. **활성화된 상품만 구독 복원**: 서버가 재시작될 때 데이터베이스에서 활성화된 상품들만 조회하여 구독을 다시 등록. 페이지네이션을 사용해 한 번에 너무 많은 데이터를 처리하지 않도록 함. `userProductRepository.findActiveMqttTopicsByActive(PageRequest.of(page, size))`를 사용해 활성화된 토픽들을 페이지 단위로 조회. |
| `Mosquitto 서버 접근 제어 문제`   | Mosquitto 서버에 누구나 접근할 수 있는 상태로 두면 보안상 문제가 발생할 수 있음. 이를 해결하기 위해 Mosquitto 서버에 접근 제어를 추가해야 한다. | Mosquitto 서버에 비밀번호를 설정하여 인증된 사용자만 접근할 수 있도록 구성. 각 클라이언트에 대한 고유한 `clientId`와 `password`를 관리하는 방식으로, 서버에 비밀번호를 몰라도 클라이언트는 파일에 저장된 정보를 통해 접근할 수 있도록 설정. |
| `IoT 온도/습도 데이터 Redis 저장 문제` | IoT 디바이스에서 온도와 습도 정보를 실시간으로 자주 받아오는 상황에서, 데이터를 매번 데이터베이스에 저장하면 DB 부하가 심할 수 있음. 이를 해결하기 위해 빠르게 데이터를 처리할 수 있는 방법이 필요함. | Redis를 활용하여 온도와 습도 데이터를 메모리에 저장한 후, 주기적인 스케줄러를 통해 데이터베이스에 한 번에 저장하는 방식으로 해결. 이를 통해 데이터베이스 부하를 줄이고, 빠른 데이터 처리를 가능하게 함. |



<br/>

## 6. 배운 기능

### * @PreDestroy *  

Spring 애플리케이션 종료 시점에 필요한 정리 작업을 수행할 수 있는 기능

#### 배운 점:  

##### 1. PreDestory의 역할  
- @PreDestroy는 빈이 소멸되기 직전에 호출되는 메서드를 정의할 때 사용  
- 주로 자원 정리, 세션 종료 처리, 캐시 저장, DB 저장 등 종료 직전 처리할 로직을 포함  

##### 2. 설정 방법  
- 메서드에 @PreDestroy를 선언하고, void 반환형으로 정의
- 파라미터를 받을 수 없으며 예외를 던지지 않는 구조로 작성해야 함 

##### 3. 적용 후 개선점  
- 불필요한 MQTT 구독 제거로 서버 재시작 시 깔끔한 상태 유지
- 자원 해제 안정성 확보 → MQTT 연결 등 외부 리소스를 명확하게 종료 가능
- 예측 가능한 종료 처리로 유지보수 용이


### * MQTT와 Mosquitto *  

**MQTT(Message Queuing Telemetry Transport)**는 경량의 메시지 큐 프로토콜로, IoT(Internet of Things) 환경에서 주로 사용되고. 저전력, 저대역폭 네트워크에서 효율적으로 데이터를 전송할 수 있어 IoT 장치 간의 실시간 메시지 통신에 적합하다. Mosquitto는 MQTT 프로토콜을 구현한 오픈소스 브로커로, MQTT 기반의 메시징 시스템을 관리하는 역할을 합니다.

#### 배운 점:  

##### 1. MQTT의 역할  
- 경량 메시징 프로토콜: IoT 환경에서 적합한 경량의 메시징 시스템으로, 낮은 대역폭과 전력 소비로 데이터를 효율적으로 전송. 
- 퍼블리시-서브스크라이브 모델: 클라이언트는 데이터를 퍼블리시(발행)하고, 다른 클라이언트는 이를 서브스크라이브(구독)하여 실시간으로 데이터를 수신.
- 주제 기반 메시지 전송: 주제(topic)를 기반으로 메시지를 전달하여, 관심 있는 주제만 구독하여 필요한 데이터만 받을 수 있음.

##### 1-2. Mosquitto의 역할
- MQTT 브로커: Mosquitto는 MQTT 프로토콜을 사용하는 브로커로, 클라이언트 간의 메시지를 중계하고, 연결, 구독 및 퍼블리시된 메시지를 관리.
- 클라이언트 관리: 클라이언트들이 연결을 설정하고, 메시지를 주고받을 수 있도록 중계하는 역할을 함
- 보안 기능: Mosquitto는 인증, 암호화, 클라이언트 ID 관리 등의 보안 기능을 제공하여 안전한 메시지 통신을 보장.

##### 2. 설정 방법  
- MQTT 연결 설정: Mosquitto 브로커와 클라이언트 간의 연결을 설정하고, 주제를 기반으로 메시지를 주고받도록 설정.
- 클라이언트 인증: Mosquitto는 사용자 인증을 위한 기능을 제공하여, MQTT 브로커에 접근하는 클라이언트를 관리.

##### 3. 적용 후 개선점  
- 실시간 데이터 전송: IoT 장치 간의 실시간 데이터 전송을 지원하여, 온도, 습도 등의 센서 데이터를 실시간으로 처리.
- 확장성: MQTT와 Mosquitto를 활용하여 수많은 IoT 장치를 효율적으로 관리하고 통신할 수 있게 됨.
- 보안 강화: Mosquitto에서 제공하는 인증 및 암호화 기능을 통해, IoT 장치 간의 안전한 데이터 통신을 보장.
- 효율적인 메시징: 퍼블리시-서브스크라이브 모델을 통해 효율적으로 데이터 전송을 관리하고, 불필요한 데이터 전송을 최소화.

### * @EventListener *  

Spring 애플리케이션에서 특정 이벤트가 발생했을 때, 이를 처리하기 위한 리스너 기능.

#### 배운 점:  

##### 1. @EventListener의 역할
- @EventListener는 애플리케이션 이벤트가 발생했을 때 이를 수신하고 처리하는 메서드를 정의하는 어노테이션입니다.
- 주로 애플리케이션의 상태 변화, 종료 등과 같은 이벤트에 반응하여 특정 작업을 실행할 때 사용됩니다. 

##### 2. 설정 방법  
- @EventListener는 메서드에 선언하여 이벤트 리스닝을 설정합니다.
- 특정 이벤트에 반응하도록 메서드를 정의하고, 해당 이벤트가 발생했을 때 실행할 로직을 작성합니다.

##### 3. 적용 후 개선점  
- 서버 종료 시점에 @PreDestroy를 사용하는 대신, @EventListener를 사용하여 애플리케이션 종료 이벤트를 수신하고, Redis 데이터를 안전하게 DB에 저장하도록 했습니다.
- Redis 연결이 종료되기 전에 이벤트 리스너가 실행되어 필요한 데이터를 처리할 수 있어, 데이터 손실을 방지하고 안정적인 종료 처리가 가능했습니다.
- 애플리케이션 종료 전에 처리해야 할 중요한 로직을 실행하는 유연한 방법을 제공하여 서버 종료 전 상태 관리에 대한 신뢰성을 높였습니다.

### * OAuth2 *  

OAuth2(Open Authorization 2.0)은 외부 애플리케이션이 사용자의 데이터를 안전하게 접근할 수 있도록 권한을 부여하는 인증 프로토콜입니다. 주로 소셜 로그인 기능에서 사용되며, 사용자가 자신의 계정 정보를 공유하지 않고도 제3자 애플리케이션이 서비스에 접근할 수 있게 도와줍니다.

#### 배운 점:  

##### 1. OAuth2의 역할
- 권한 부여: 사용자가 자신의 인증 정보를 직접 제공하지 않고, 외부 애플리케이션이 안전하게 사용자 데이터를 접근할 수 있도록 권한을 부여.
- 액세스 토큰 발급: 사용자가 로그인하면, 인증 서버는 클라이언트 애플리케이션에 액세스 토큰을 발급. 이를 통해 외부 애플리케이션은 사용자의 데이터를 안전하게 조회할 수 있음.

##### 2. 설정 방법  
- OAuth2 설정: 인증 서버(예: Google, Facebook, Kakao)와의 연결을 설정하고, 액세스 토큰을 요청할 수 있도록 클라이언트 애플리케이션을 구성.
- 소셜 로그인 구현: OAuth2 프로토콜을 사용하여 소셜 로그인 시스템을 구현하고, 다양한 소셜 플랫폼에서 제공하는 인증 API를 통해 사용자의 로그인 정보를 처리.
- 토큰 저장: 발급된 액세스 토큰과 리프레시 토큰을 클라이언트 애플리케이션에 안전하게 저장하여 사용.

##### 3. 적용 후 개선점  
- 간편한 소셜 로그인: 기존의 복잡한 소셜 로그인 로직을 간소화하여 보안적이고 효율적인 로그인 프로세스 구현과 정보에 민감한 code 등 url등을 서비스에서 이용 안할 수 있어 보안적으로 개선.
- 보안성 강화: 사용자 인증 정보를 클라이언트 애플리케이션에 저장하지 않고, 안전하게 인증 서버를 통해 처리. 액세스 토큰을 사용하여 외부 애플리케이션에서만 사용자의 데이터를 접근 가능.
- 유연한 권한 관리: OAuth2 프로토콜을 통해 특정 범위(scope)만 요청하여, 사용자의 개인정보를 최소화하고 보호할 수 있음.






<br/>


## 7. 느낀점


