# 🌡️IoT-TempLog💧

<br/><br/>

## 소개 및 개요
- 프로젝트 기간 : 2025.03.14 ~ 2025.03.21
- 인원 : 임홍현 <backend>
- github : [@limhhyeon](https://github.com/limhhyeon)


### [프로젝트 소개]:
#### [개요]
- 이 프로젝트는 가스 벨브를 잠그지 않고 외출한 경험에서 아이디어를 얻어 시작되었습니다. 당시 불안한 마음에 집의 온도와 습도를 실시간으로 확인할 수 있는 시스템을 만들기로 결심하게 되었습니다. 이를 바탕으로 온도 및 습도 모니터링 시스템을 설계하여, 위험 상황을 미리 감지하고 알림을 받을 수 있는 기능을 제공하고자 했습니다.
#### [설명]
- 본 시스템은 ESP32 DHT22 센서를 사용하여 실시간 온도와 습도를 측정하고, 이를 MQTT Mosquitto 브로커를 통해 웹 서버로 전송합니다. 사용자는 설정된 온도 차이나 습도 기준을 초과할 경우, 실시간으로 이메일 알림을 받을 수 있으며, 이메일 알림 기능은 사용자가 선택적으로 활성화할 수 있어 불필요한 알림을 방지할 수 있습니다. 특히, 온도 차이가 일정 범위를 초과할 때 발생하는 알림은 위험 상황을 사전에 감지하여 사용자가 빠르게 대응할 수 있도록 돕습니다.
- 또한, 이 프로젝트는 카카오 소셜 로그인을 지원하여 사용자가 친구들과 쉽게 시스템을 공유하고 사용할 수 있도록 하였으며, 보안 측면에서는 JWT 인증과 HttpOnly 쿠키를 활용하여 웹 보안을 강화했습니다. 만약 기기가 연결 끊어짐 현상이 발생하면, Redis를 사용하여 구독 상태를 관리하고, 기기가 재연결될 경우 자동으로 구독을 복구할 수 있도록 설계되었습니다.
- 데이터 관리 측면에서 실시간 온도 및 습도 정보를 Redis에 캐시하여 빠르게 제공하고, 2시간마다 평균값을 DB에 저장하는 방식으로 효율적인 데이터 처리와 저장을 보장합니다. 이를 통해 사용자는 중요한 데이터가 빠르고 정확하게 제공되며, 시스템의 성능이 최적화됩니다.
#### [사전조사]
- `온도와 습도 확인 방법에 대한 의견`:
    - 대부분의 사용자들이 **현재 시점의 온도와 습도만 확인**하는 방식에 대해 선호한다고 응답. 실시간으로 변화하는 온도와 습도를 계속 확인하는 것보다는 **현재 상태**나 **하루 평균**에 대한 정보가 더 유용하다는 의견이 많았음.
    - 사용자는 **1분 단위의 온도 변화**보다는 **현재 시점의 상태**나 **하루 평균**에 대한 관심이 크다는 피드백을 주었음.
- `온도 차이로 인한 실시간 알림 수신에 대한 필요성`:
    - **내 경험**: 한 번 가스 벨브(가스불X)를 잠그지 않고 외출한 적이 있었는데, 큰 문제는 발생하지 않았지만 이런 상황이 다른 사람들에게도 있을 수 있다고 생각했습니다. 그래서 온도 차이가 일정 범위를 초과할 경우 실시간 알림을 받을 수 있는 기능을 생각하게 되었다.
    - 대부분의 사용자들에게 물어봤을 떄 이 기능에 대해 필요성을 보였음. 온도 차이가 **위험 수준**에 도달했을 때 이를 실시간 알림으로 받을 수 있는 기능은 **안전성**을 높이고, **위험 상황을 사전에 감지**할 수 있어 매우 유용하다는 반응을 보였음.
    - 사용자들은 **위험 상황**을 미리 감지하고, 이를 실시간 알림으로 받아 **즉시 대응**할 수 있는 기능에 대해 **긍정적**인 반응을 보였음.




<br/>

## 2. 기술 스택
### [사용 기술]
#### **🛠️ Backend**  
![Java](https://img.shields.io/badge/java-%23ED8B00.svg?style=for-the-badge&logo=openjdk&logoColor=white) ![Spring](https://img.shields.io/badge/spring-%236DB33F.svg?style=for-the-badge&logo=spring&logoColor=white) ![Gradle](https://img.shields.io/badge/Gradle-02303A.svg?style=for-the-badge&logo=Gradle&logoColor=white) ![Hibernate](https://img.shields.io/badge/Hibernate-59666C?style=for-the-badge&logo=Hibernate&logoColor=white)  
- **QueryDsl** : 오타 발생 방지를 위한 queryDls 사용  
- **Spring Security** : 인증 및 권한 관리  
- **SLF4J** : 애플리케이션 로깅을 위해 사용   
- **Spring Schedule** : 일정 시간마다 db 저장을 위한 스케줄 사용
- **MQTT** : IoT 기기와의 메시지 중계 및 실시간 데이터 처리에 사용

#### **💻 Database & Cache**    
 ![MariaDB](https://img.shields.io/badge/MariaDB-003545?style=for-the-badge&logo=mariadb&logoColor=white)
![Redis](https://img.shields.io/badge/redis-%23DD0031.svg?style=for-the-badge&logo=redis&logoColor=white)  


#### **☁️ DevOps & Deployment**    
![AWS](https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&logo=amazon-aws&logoColor=white)
![Mosquitto](https://img.shields.io/badge/mosquitto-%233C5280.svg?style=for-the-badge&logo=eclipsemosquitto&logoColor=white)
![Docker](https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)
![Nginx](https://img.shields.io/badge/nginx-%23009639.svg?style=for-the-badge&logo=nginx&logoColor=white)
![GitHub Actions](https://img.shields.io/badge/github%20actions-%232671E5.svg?style=for-the-badge&logo=githubactions&logoColor=white)  
- **AWS EC2** : 클라우드 서버  
- **AWS RDS(MariaDB)** : 클라우드 DB 관리



### [커밋 처리]
![GitHub](https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&logo=github&logoColor=white)

```java
feat: 새로운 기능을 추가했을 때
fix: 버그를 수정했을 때
refactor: 코드 개선했을 때
perf: 성능 최적화할 때
build: 빌드 시스템이나 외부 의존성 변경할 때
```
<br/>

## 3. System Architecture & ERD
### [Deployment Plan]
<img src="https://github.com/user-attachments/assets/b69d3a5b-179c-4b23-859f-a4eeb18978a2" alt="Iot디플로이 전략" width="700"/>

#### broker 처리  
<img src="https://github.com/user-attachments/assets/340661cc-c545-4789-ba4d-b800c4ff6dff" alt="아이오티 전송 개념2" width="700"/>  

1. 기기에서 MQTT 메시지를 발행 (publish)  
2. Mosquitto MQTT 브로커에서 해당 메시지를 수신  
3. 애플리케이션에서 MQTT 클라이언트 등록 (clientId 설정)  
4. 애플리케이션에서 MQTT 채널 등록 후 구독 (subscribe)  
5. 애플리케이션에서 메시지 수신 후 처리 (예: 알림, DB 저장 등)  


### [ERD]
![iotErd](https://github.com/user-attachments/assets/4074d0f0-5742-4cee-a1d0-c385c4ef00bb)


<br/>

## 4. 기능 전략

#### `1. Auth`
- 이메일 중복 확인을 통해 회원 가입 시 이미 등록된 이메일이 없는지 확인하고, 회원가입 시에는 이메일과 비밀번호 등 필수 정보를 입력받아 신규 사용자를 등록합니다. 사용자 인증을 강화하기 위해 이메일 인증 절차를 도입하여, 인증번호를 이메일로 발송하고 사용자가 이를 입력하면 이메일을 사용할 수 있도록 설정했습니다.
- 로그인 후 보안을 강화하기 위해 JWT 토큰 관리를 적용하여, 로그인 시 HttpOnly 및 secure 속성을 가진 쿠키에 JWT 토큰을 저장하고, 이를 보안 필터로 관리합니다. 리프레시 토큰 관리는 DB에서 처리되며, 액세스 토큰이 만료될 경우 이를 갱신할 수 있도록 리프레시 토큰을 사용합니다. 또한, 간편한 로그인 방법을 제공하기 위해 소셜 로그인 기능을 추가하여, 사용자가 카카오 계정을 이용해 손쉽게 로그인할 수 있도록 구현했습니다.

#### `2. Product`
2-1) 클라이언트 사이드 (제품에 대한 설계)
- 제품은 클라이언트 ID와 비밀번호를 내장하고 있어, Mosquitto 서버와의 연결 시 인증을 통해 안전하게 데이터를 전송합니다. 온도 및 습도 정보는 1분마다 Mosquitto 서버로 전송된다. 또한, Wi-Fi 연결을 위해 IoT 제품은 Wi-Fi 기능을 갖추고 있으며, WiFiManager를 사용하여 사용자가 주변 Wi-Fi 네트워크를 등록할 수 있도록 설계되었습니다.

2-2) 서버 사이드 (서버에서 상품에 대한 설계)
- 서버에서는 판매된 상품만 API를 통해 구매된 후 DB에 등록되도록 설계되었습니다. IoT 제품은 판매 전에는 DB에 등록되지 않으며, 상품 번호 등록을 통해 사용자가 웹사이트에서 구매한 상품을 등록합니다. 또한, 알림 설정 기능을 제공하여 사용자가 설정한 기준에 따라 알림을 받을지 여부를 선택할 수 있습니다.

#### `3. Sensor`
- 온도와 습도 데이터는 실시간으로 Redis에 저장하여 DB 부하를 줄이고, 빠르게 데이터를 가져와 API를 통해 사용자에게 제공합니다. 또한, 스케줄러를 활용해 평균 온도/습도 데이터를 2시간 간격으로 DB에 저장하며, 사용자가 설정한 기준을 초과하는 변화가 발생할 경우 자동으로 메일을 전송하는 기능을 구현했습니다.
- 사용자는 알림 기준을 직접 설정할 수 있으며, 설정한 조건에 따라 습도가 경고 수준을 넘거나 온도 차이가 발생하면 실시간으로 메일이 발송됩니다. 이 과정은 백그라운드에서 처리되어 사용자에게 빠른 알림을 제공합니다.

#### `4. Mosquitto && 애플리케이션 서버`
- Mosquitto 서버는 보안을 강화하기 위해 비밀번호를 설정하여 외부에서 무단으로 접근할 수 없도록 했습니다. 또한, DHT22 제품에는 고유의 클라이언트 ID와 비밀번호를 내장하여, 인증된 클라이언트만 서버에서 구독할 수 있도록 설계하였습니다. 구독 관리 측면에서는 제품이 꺼지면 해당 제품에 대한 구독을 취소하고, 서버가 종료되었을 때는 활성화된 제품만 구독하여 리소스 낭비를 줄였습니다. 제품의 상태 변경은 Redis에 기록되며, 주기적으로 DB에 상태를 저장하여 효율적인 데이터 관리를 구현하였습니다.


## 5. 트러블 슈팅


| 🔴 오류                           | 🔵 문제                                                                 | 🟢 해결 방법                                                               |
|---------------------------------|----------------------------------------------------------------------|--------------------------------------------------------------------------|
| `@PreDestroy에서 발생한 예외처리`  | `@PreDestroy`에서 Redis에서 값을 가져오기 전에 Redis 연결이 끊겨서 해당 값을 가져오지 못해 로그가 찍히지 않고 `@PreDestroy`가 실행되지 않음. | `@PreDestroy`가 실행되기 전에 Redis에서 먼저 값을 가져와 DB에 저장하는 로직을 `EventListener`로 처리하여, Redis와의 연결을 끊기 전에 값을 저장하도록 수정. |
| `DHT22 기기의 상태를 확인하는 방법` | 기기의 상태(켜짐/꺼짐)를 어떻게 알 수 있을지 고민하고 있었고, MQTT를 사용하여 기기의 상태를 관리하는 방법을 찾음. | MQTT Client를 사용하여 기기의 상태를 관리하고, `device/status/#` 토픽을 구독하여 기기의 상태 변경(켜짐/꺼짐)을 실시간으로 확인하고 처리하도록 함. |
| `서버 재시작 시 MQTT 구독 복원 문제` | 서버가 재시작된 후, MQTT에서 구독한 토픽들이 사라지고 다시 구독을 등록해야 하는 문제 발생. 특히, 상품 등록 시에만 구독을 하도록 설정했지만, 서버가 꺼졌다 켜지면 모든 구독 정보가 사라져 다시 등록해야 함. | 서버가 재시작될 때 활성화된 상품에 대해서만 구독을 다시 하도록 설정. 불필요한 구독을 피하기 위해 데이터베이스에서 활성화된 상품만 구독하도록 필터링하고, 페이지네이션을 통해 한 번에 너무 많은 데이터를 처리하지 않도록 수정. 1. **MQTT 연결 재시도 로직 추가**: MQTT 연결이 제대로 되지 않으면 최대 5번까지 재시도하며 연결을 시도. 연결이 실패하면 로그를 찍고 구독 초기화 실패 처리. 2. **활성화된 상품만 구독 복원**: 서버가 재시작될 때 데이터베이스에서 활성화된 상품들만 조회하여 구독을 다시 등록. 페이지네이션을 사용해 한 번에 너무 많은 데이터를 처리하지 않도록 함. `userProductRepository.findActiveMqttTopicsByActive(PageRequest.of(page, size))`를 사용해 활성화된 토픽들을 페이지 단위로 조회. |
| `Mosquitto 서버 접근 제어 문제`   | Mosquitto 서버에 누구나 접근할 수 있는 상태로 두면 보안상 문제가 발생할 수 있음. 이를 해결하기 위해 Mosquitto 서버에 접근 제어를 추가해야 한다. | Mosquitto 서버에 비밀번호를 설정하여 인증된 사용자만 접근할 수 있도록 구성. 각 클라이언트에 대한 고유한 `clientId`와 `password`를 관리하는 방식으로, 서버에 비밀번호를 몰라도 클라이언트는 파일에 저장된 정보를 통해 접근할 수 있도록 설정. |
| `IoT 온도/습도 데이터 Redis 저장 문제` | IoT 디바이스에서 온도와 습도 정보를 실시간으로 자주 받아오는 상황에서, 데이터를 매번 데이터베이스에 저장하면 DB 부하가 심할 수 있음. 이를 해결하기 위해 빠르게 데이터를 처리할 수 있는 방법이 필요함. | Redis를 활용하여 온도와 습도 데이터를 메모리에 저장한 후, 주기적인 스케줄러를 통해 데이터베이스에 한 번에 저장하는 방식으로 해결. 이를 통해 데이터베이스 부하를 줄이고, 빠른 데이터 처리를 가능하게 함. |



<br/>

## 6. Lessons Learned


### Lessons

### *서버 종료 시 @PreDestroy 활용한 기기 상태 저장 및 구독 주소 정리*

프로젝트를 진행하면서 **서버 종료 시 기기 상태 저장**과 **구독 주소 정리**를 위해 **@PreDestroy** 애너테이션을 활용하는 방법을 배웠습니다. 이를 통해 서버가 종료되기 전에 기기 상태를 DB에 저장하고, 구독 주소를 정리하는 작업을 자동화할 수 있었습니다.

#### [배운 점]:

##### 1. **@PreDestroy의 역할**
- **빈 소멸 전 자동 호출**: 애플리케이션이 종료될 때, 빈이 컨테이너에서 제거되기 전에 호출되는 메서드를 지정하는 애너테이션  
- **리소스 정리**: 서버나 애플리케이션 종료 시 리소스를 정리하고 메모리 누수를 방지하는 데 유용  
- **일관된 종료 작업**: 모든 빈에서 동일한 방식으로 종료 작업을 처리할 수 있어 코드 유지보수가 용이  
- **Spring 관리의 편리함**: Spring이 빈의 생명 주기를 관리하므로 명시적으로 종료 메서드를 호출할 필요 없이 Spring이 자동으로 처리해줌  

##### 2. **설정 방법**
- **Redis에서 기기 상태 값 가져오기**: 
  - 서버 종료 전에 `@PreDestroy` 메서드에서 Redis에 저장된 기기 상태 값을 DB에 저장하는 로직을 구현
- **구독 주소 정리**: 
  - 서버 종료 시  구독 주소를 정리하는 작업을 수행

##### 3. **적용 후 개선점**
- **자동화된 종료 작업**:  구독 주소를 정리하여 시스템의 일관성을 유지  
- **효율적인 리소스 관리**: `@PreDestroy` 애너테이션을 통해 리소스를 자동으로 정리하고, 서버 종료 시 메모리 누수를 방지  

서버 종료 시 **구독 주소 정리**를 자동화함으로써 **서버 종료 시 발생할 수 있는 데이터 손실**을 방지하고, **효율적인 리소스 관리를** 실현할 수 있었습니다. 🚀

---
### *@EventListener를 활용한 Redis 데이터 저장 처리*

프로젝트를 진행하면서 **서버 종료 시 기기 상태 저장**과 **구독 주소 정리**를 위해 **@PreDestroy** 애너테이션을 사용하려 했으나, Redis 연결이 먼저 종료되어 @PreDestroy가 발생 안하는 문제가 발생했다. 그래서 `@EventListener`를 활용하여 Redis에 값을 먼저 저장하는 방법을 배웠습니다.

#### [배운 점]:

##### 1. **@EventListener의 역할**
- **이벤트 기반 처리**: 특정 이벤트가 발생할 때 지정된 메서드가 실행되도록 하는 애너테이션  
- **서버 종료 이벤트 처리**: 서버가 종료되거나 특정 이벤트가 발생할 때 이를 감지하여 필요한 작업을 처리하는 데 사용  

##### 2. **문제와 해결 과정**
- **문제 발생**: `@PreDestroy`를 사용하여 서버 종료 시 Redis에서 데이터를 가져와 DB에 저장하는 로직을 작성했으나, Redis 연결이 먼저 끊겨 전에 값이 저장되지 않아 `@PreDestroy` 메서드가 실행되지 않았음  
- **해결 방법**: `@EventListener`를 활용하여 Redis에서 값을 먼저 가져오고 DB에 저장하는 로직을 처리. 이를 통해 Redis와 DB 간의 데이터 동기화를 서버 종료 전에 완료할 수 있었음

##### 3. **설정 방법**
- **@EventListener 사용**:
  - `@EventListener`를 사용하여 서버 종료 이벤트를 감지하고, Redis에서 값을 먼저 가져와 DB에 저장하는 로직을 추가
  - Redis에서 데이터가 없으면 DB에서 가져오고, Redis에 캐시하여 빠른 조회가 가능하도록 구현  
- **구독 주소 정리**: 서버 종료 시 Redis 연결이 끊기기 전에 구독 주소를 정리하는 작업을 `@EventListener`로 처리
  
#####`4. **적용 후 개선점**
- **데이터 일관성 유지**: `@EventListener`를 사용하여 Redis와 DB 간의 데이터 동기화를 처리하여 데이터의 일관성을 유지할 수 있었음  
- **자동화된 종료 작업**: 서버 종료 시 필요한 데이터를 자동으로 저장하고 구독 주소를 정리하여 서버 종료 후에도 불필요한 구독 주소가 남아있지 않음 
- **효율적인 리소스 관리**: `@EventListener`를 사용하여 필요한 데이터를 종료 전에 처리하고 리소스를 효율적으로 관리할 수 있었음  

`@EventListener`를 도입함으로써 **서버 종료 시 Redis와 DB의 데이터 동기화** 및 **구독 주소 정리**를 원활하게 처리할 수 있었습니다. 이를 통해 **데이터 일관성**과 **시스템 안정성**을 높일 수 있었습니다. 🚀

---
### *MQTT Client를 활용한 기기 상태 관리*

 **기기의 상태**(켜짐/꺼짐)를 어떻게 확인할 수 있을지에 대해 고민하게 되었습니다. 그 결과, **MQTT Client**를 사용하여 구독 주소를 따로 만들어, 기기의 상태를 관리하는 방법을 알게 되었습니다.

#### [배운 점]:

##### 1. **MQTT Client의 역할**
- **MqttClient**는 MQTT 브로커(서버)와 클라이언트 간의 메시지를 주고받는 데 사용되는 객체
- MQTT 브로커에 연결하고, **퍼블리시(publish)**하거나, 특정 **토픽(topic)**을 **구독(subscribe)**하여 수신된 메시지를 처리합니다.
- **기기 상태 관리**: 기기가 **켜짐/꺼짐** 상태를 관리하기 위해 MQTT 클라이언트를 사용하여, 해당 정보를 다른 클라이언트들이 쉽게 구독할 수 있도록 합니다.

##### 2. **장점**
1. **연결 유지 및 자동 재연결**
   - MQTT 클라이언트는 연결이 끊어졌을 때 자동으로 재연결을 시도합니다. 이는 불안정한 네트워크 환경에서 매우 유용합니다.
   - **세션 지속성**을 지원하여, 클라이언트가 오프라인 상태에서 다시 온라인이 되었을 때, 이전의 메시지를 받을 수 있습니다.

2. **작은 네트워크 부담**
   - MQTT는 헤더 크기가 작고 최소한의 데이터만 전송하므로 네트워크 대역폭을 효율적으로 사용합니다. 이는 배터리 기반 IoT 장치에서 중요한 요소입니다.

3. **지원하는 다양한 기능**
   - **Last Will and Testament (LWT)**: MQTT는 연결이 끊어진 클라이언트에 대한 상태 알림을 지원합니다. 클라이언트가 예기치 않게 종료될 때, 사전에 정의된 메시지를 발행하여 다른 클라이언트에게 이를 알릴 수 있습니다.

##### 3. **기기 상태 관리 구현**
기기 상태를 관리하기 위해 **MQTT Client**를 사용하여, 각 기기의 상태를 실시간으로 구독하고 처리할 수 있습니다. 기기가 꺼지거나 켜질 때 상태를 업데이트하고, 이를 **MQTT 토픽**을 통해 다른 클라이언트와 공유합니다.

##### 4. **사용법**
1. **MQTT Client Bean 등록**: `MqttClient`를 Spring의 **빈**으로 등록하여 애플리케이션에서 재사용할 수 있도록 합니다.

##### 5. 적용 후 개선점

###### 1. **기기 상태 추적**
- MQTT 클라이언트를 사용하여 기기 상태를 실시간으로 업데이트합니다.
- 서버가 시작할 때 **모든 구독이 취소되는 문제**를 해결할 수 있었습니다. 
- 기기 상태를 실시간으로 추적하여 기기가 꺼지거나 켜질 때 상태를 정확하게 알 수 있습니다.

###### 2. **효율적인 네트워크 사용**
- **MQTT**는 적은 데이터 전송량과 빠른 메시지 전달로 기기 상태를 **효율적으로 관리**할 수 있습니다.
- 작은 헤더 크기와 최소한의 데이터 전송 덕분에, 네트워크 대역폭을 효율적으로 사용할 수 있어 IoT 환경에서 매우 유용합니다.

###### 3. **구독 관리**
- 기기가 켜져 있는지 꺼져 있는지를 별도의 **구독 주소**에서 관리하여, 서버 시작 시 기기 상태를 자동으로 구독하고 처리할 수 있습니다.
- 서버가 시작되면 MQTT 클라이언트를 사용하여 **기기 상태**에 맞게 구독을 설정하고 상태 변화를 추적합니다.

---

### Learned

- **Redis를 활용하여 성능을 최적화**하면서, 데이터 저장 전략을 보다 효율적으로 설계하는 방법을 배웠다. Redis를 사용하여 실시간 채팅 메시지 저장, 유저 데이터 캐싱 등 다양한 사용 사례에 적용하였으며, 이를 통해 DB 부하를 줄이고 빠른 응답 속도를 달성할 수 있었다.

- **MQTT 클라이언트를 사용한 기기 상태 관리** 방법을 학습하였다. 서버가 시작될 때 모든 구독이 취소되는 문제를 해결하기 위해 MQTT를 활용하여 기기 상태를 실시간으로 추적하고, 네트워크 부담을 최소화하면서 효율적인 상태 관리를 할 수 있었다. 이로써 기기 상태 변화를 즉각적으로 반영할 수 있는 시스템을 구현할 수 있었다.

- **@EventListener를 활용하여 상태 변경 시 필요한 작업을 처리**하는 방법을 배웠다. Redis와 DB 간의 상태 동기화 및 구독 주소 정리 등, 서버 종료 시 필요한 작업을 이벤트 기반으로 처리하여 안정적인 상태 유지를 할 수 있었다.

- **Spring의 @PreDestroy 애너테이션**을 통해 서버 종료 시 리소스 정리 및 데이터 저장 작업을 자동으로 처리하는 방법을 배웠다. 이를 통해 서버가 종료되기 전에 필요한 작업을 간결하고 일관되게 처리할 수 있었다.


<br/>


## 7. 느낀점
- 우선 내가 사용하려고 만든 프로젝트를 설계하면서 많은 기능이 아닌 간단한 기능을 구현하는 대신 그 안에서  고려할 점을 찾아서 성능에 대해 고려해보자라고 하면서 시작을 했다. 하지만 생각했던 것보다 고려할게 너무 많아 머리가 아팠던 거 같다.. 왜냐하면 새로운 것도 많고 그거에 대해 공부까지 하고 적용해보려 하니 힘이 많이 들었던 것 같다. 하지만 내가 편리하게 쓰려면 만들어야지 이 생각으로 더 열심히 만들었고 성공하니 너무 뿌듯했다.
- 우선은 mosquitto서버 파일에 유저 아이디랑 비밀번호를 계속 추가해줘야되는 불편한 점이 있는데 Iot 제품이 mosquitto 서버에 접근하려고 할 때 어떤식으로 하는지 더 알아보고 싶어졌다. 

